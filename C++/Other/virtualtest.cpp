/*
基底クラスのメンバメソッドを継承クラスで変更する事ができる。簡単に言えば、再定義するという事。この基底クラスの関数（オーバーライドされる関数）を「仮想関数」という。
スコープ演算指定子で、基底クラスのメソッドを指定してやれば、オーバーライドする前の基底クラスのメソッドを呼び出す事ができる。
基底クラスのポインタに派生クラスのオブジェクトを代入して、アクセスした場合は、基底クラス内ではオーバーライドしたメソッドを知らないので、基底クラスのメソッドが呼び出される。

通常、オーバーライドしてもらいたいメソッドには「virtual」指定子をつけてあげる事がある。virtual指定子がなくてもオーバーライドする事は可能。

*/


#include <iostream>
using namespace std;

class Parent
{
public:
  void func(void)
  {
    cout << "基底クラスのメソッドです" << endl;
  }
};

class Child : public Parent
{
public:
  //オーバーライドしたメソッド
  void func(void)
  {
    cout << "派生クラスのメソッドです" << endl;
  }
};

int main(int argc, char** argv)
{
  Parent *p_parent;
  Child i_child;
  p_parent = &i_child; //parent型の変数ポインタにchildインスタンスのポインタを入れる
  i_child.func();        //オーバーライドしたメソッドを呼び出す
  i_child.Parent::func();//基底クラスのメソッドを呼び出す
  p_parent->func();      //派生クラスのオブジェクトを基底クラスのポインタに代入したメソッドを呼び出す
  return(0);
}

/*
派生クラスのメソッドです　(インスタンスのメソッド->インスタンスのメソッド)
基底クラスのメソッドです　(どこのメソッドかスコープ解決演算子で明示)
基底クラスのメソッドです　(変数自体のメソッド->変数の型の命令)

ってなるxxx
*/



